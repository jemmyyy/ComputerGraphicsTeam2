import { mat3, mat4 } from 'gl-matrix';
import { newInstance as newInstance$1, setGet } from '../../macros.js';
import vtkMapper from '../Core/Mapper.js';
import vtkProperty from '../Core/Property.js';
import vtkTexture from '../Core/Texture.js';
import vtkWebGPUBufferManager from './BufferManager.js';
import vtkWebGPUShaderCache from './ShaderCache.js';
import vtkWebGPUUniformBuffer from './UniformBuffer.js';
import vtkWebGPUSimpleMapper from './SimpleMapper.js';

var BufferUsage = vtkWebGPUBufferManager.BufferUsage,
    PrimitiveTypes = vtkWebGPUBufferManager.PrimitiveTypes;
var Representation = vtkProperty.Representation;
var ScalarMode = vtkMapper.ScalarMode;
var vtkWebGPUPolyDataVS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@stage(vertex)\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n";
var vtkWebGPUPolyDataFS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@stage(fragment)\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;\n  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;\n  var opacity: f32 = mapperUBO.Opacity;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  var computedColor: vec4<f32> = vec4<f32>(ambientColor.rgb * mapperUBO.AmbientIntensity\n     + diffuse * mapperUBO.DiffuseIntensity\n     + specular * mapperUBO.SpecularIntensity,\n     opacity);\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  if (computedColor.a == 0.0) { discard; };\n\n  //VTK::Position::Impl\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";

function isEdges(hash) {
  // edge pipelines have "edge" in them
  return hash.indexOf('edge') >= 0;
} // ----------------------------------------------------------------------------
// vtkWebGPUCellArrayMapper methods
// ----------------------------------------------------------------------------


function vtkWebGPUCellArrayMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUCellArrayMapper');

  publicAPI.buildPass = function (prepass) {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
    }
  }; // Renders myself


  publicAPI.translucentPass = function (prepass) {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };

  publicAPI.opaquePass = function (prepass) {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };

  publicAPI.updateUBO = function () {
    // make sure the data is up to date
    var actor = model.WebGPUActor.getRenderable();
    var ppty = actor.getProperty();
    var utime = model.UBO.getSendTime();

    if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {
      var keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
      model.UBO.setArray('BCWCMatrix', keyMats.bcwc);
      model.UBO.setArray('BCSCMatrix', keyMats.bcsc);
      model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);
      var aColor = ppty.getAmbientColorByReference();
      model.UBO.setValue('AmbientIntensity', ppty.getAmbient());
      model.UBO.setArray('AmbientColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());
      aColor = ppty.getDiffuseColorByReference();
      model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      model.UBO.setValue('SpecularIntensity', ppty.getSpecular());
      model.UBO.setValue('SpecularPower', ppty.getSpecularPower());
      aColor = ppty.getSpecularColorByReference();
      model.UBO.setArray('SpecularColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      model.UBO.setValue('LineWidth', ppty.getLineWidth());
      aColor = ppty.getEdgeColorByReference();
      model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);
      model.UBO.setValue('Opacity', ppty.getOpacity());
      model.UBO.setValue('PropID', model.WebGPUActor.getPropID());
      var device = model.WebGPURenderWindow.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };

  publicAPI.haveWideLines = function () {
    var actor = model.WebGPUActor.getRenderable();
    var representation = actor.getProperty().getRepresentation();

    if (actor.getProperty().getLineWidth() <= 1.0) {
      return false;
    }

    if (model.primitiveType === PrimitiveTypes.Verts) {
      return false;
    }

    if (model.primitiveType === PrimitiveTypes.Triangles || model.primitiveType === PrimitiveTypes.TriangleStrips) {
      return representation === Representation.WIREFRAME;
    }

    return true;
  };

  publicAPI.replaceShaderPosition = function (hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
    var code = vDesc.getCode();

    if (publicAPI.haveWideLines()) {
      vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex'); // widen the edge

      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = tmpPos2.z + 0.00001;', // could become a setting
      '    output.Position = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);']).result;
    } else {
      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;']).result;
    }

    vDesc.setCode(code);
  };

  model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);

  publicAPI.replaceShaderNormal = function (hash, pipeline, vertexInput) {
    var normalBuffer = vertexInput.getBuffer('normalMC');

    if (normalBuffer) {
      var vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);
      var code = vDesc.getCode();
      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);']).result;
      vDesc.setCode(code);
      var fDesc = pipeline.getShaderDescription('fragment');
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }']).result;
      fDesc.setCode(code);
    }
  };

  model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal); // we only apply lighting when there is a "var normal" declaration in the
  // fragment shader code. That is the lighting trigger.

  publicAPI.replaceShaderLight = function (hash, pipeline, vertexInput) {
    var fDesc = pipeline.getShaderDescription('fragment');
    var code = fDesc.getCode();

    if (code.includes('var normal')) {
      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  var df: f32  = max(0.0, normal.z);', '  var sf: f32 = pow(df, mapperUBO.SpecularPower);', '  var diffuse: vec3<f32> = df * diffuseColor.rgb;', '  var specular: vec3<f32> = sf * mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;']).result;
      fDesc.setCode(code);
    } else {
      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;']).result;
      fDesc.setCode(code);
    }
  };

  model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);

  publicAPI.replaceShaderColor = function (hash, pipeline, vertexInput) {
    if (isEdges(hash)) {
      var _fDesc = pipeline.getShaderDescription('fragment');

      var _code = _fDesc.getCode();

      _code = vtkWebGPUShaderCache.substitute(_code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;

      _fDesc.setCode(_code);

      return;
    }

    var colorBuffer = vertexInput.getBuffer('colorVI');
    if (!colorBuffer) return;
    var vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;
    fDesc.setCode(code);
  };

  model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);

  publicAPI.replaceShaderTCoord = function (hash, pipeline, vertexInput) {
    if (!vertexInput.hasAttribute('tcoord')) return;
    var vDesc = pipeline.getShaderDescription('vertex');
    vDesc.addOutput('vec2<f32>', 'tcoordVS');
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription('fragment');
    code = fDesc.getCode(); // todo handle multiple textures? Blend multiply ?

    if (model.textures.length) {
      code = vtkWebGPUShaderCache.substitute(code, '//VTK::TCoord::Impl', ['var tcolor: vec4<f32> = textureSample(Texture0, Texture0Sampler, input.tcoordVS);', 'computedColor = computedColor*tcolor;']).result;
    }

    fDesc.setCode(code);
  };

  model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);

  publicAPI.replaceShaderSelect = function (hash, pipeline, vertexInput) {
    if (hash.includes('sel')) {
      var fDesc = pipeline.getShaderDescription('fragment');
      var code = fDesc.getCode(); // by default there are no composites, so just 0

      code = vtkWebGPUShaderCache.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;
      fDesc.setCode(code);
    }
  };

  model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);

  publicAPI.getUsage = function (rep, i) {
    if (rep === Representation.POINTS || i === PrimitiveTypes.Points) {
      return BufferUsage.Verts;
    }

    if (i === PrimitiveTypes.Lines) {
      return BufferUsage.Lines;
    }

    if (rep === Representation.WIREFRAME) {
      if (i === PrimitiveTypes.Triangles) {
        return BufferUsage.LinesFromTriangles;
      }

      return BufferUsage.LinesFromStrips;
    }

    if (i === PrimitiveTypes.Triangles) {
      return BufferUsage.Triangles;
    }

    if (i === PrimitiveTypes.TriangleStrips) {
      return BufferUsage.Strips;
    }

    if (i === PrimitiveTypes.TriangleEdges) {
      return BufferUsage.LinesFromTriangles;
    } // only strip edges left which are lines


    return BufferUsage.LinesFromStrips;
  };

  publicAPI.getHashFromUsage = function (usage) {
    return "pt".concat(usage);
  };

  publicAPI.getTopologyFromUsage = function (usage) {
    switch (usage) {
      case BufferUsage.Triangles:
        return 'triangle-list';

      case BufferUsage.Verts:
        return 'point-list';

      case BufferUsage.Lines:
      default:
        return 'line-list';
    }
  };

  publicAPI.buildVertexInput = function () {
    var pd = model.currentInput;
    var cells = model.cellArray;
    var primType = model.primitiveType;
    var actor = model.WebGPUActor.getRenderable();
    var representation = actor.getProperty().getRepresentation();
    var device = model.WebGPURenderWindow.getDevice();
    var edges = false;

    if (primType === PrimitiveTypes.TriangleEdges) {
      edges = true;
      representation = Representation.WIREFRAME;
    }

    var vertexInput = model.vertexInput;
    var points = pd.getPoints();
    var indexBuffer; // get the flat mapping indexBuffer for the cells

    if (cells) {
      var buffRequest = {
        hash: "R".concat(representation, "P").concat(primType).concat(cells.getMTime()),
        usage: BufferUsage.Index,
        cells: cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: primType,
        representation: representation
      };
      indexBuffer = device.getBufferManager().getBuffer(buffRequest);
      vertexInput.setIndexBuffer(indexBuffer);
    } else {
      vertexInput.setIndexBuffer(null);
    } // hash = all things that can change the values on the buffer
    // since mtimes are unique we can use
    // - indexBuffer mtime - because cells drive how we pack
    // - relevant dataArray mtime - the source data
    // - shift - not currently captured
    // - scale - not currently captured
    // - format
    // - usage
    // - packExtra - covered by format
    // points


    if (points) {
      var shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
      var _buffRequest = {
        hash: "".concat(points.getMTime(), "I").concat(indexBuffer.getMTime()).concat(shift.join(), "float32x4"),
        usage: BufferUsage.PointArray,
        format: 'float32x4',
        dataArray: points,
        indexBuffer: indexBuffer,
        shift: shift,
        packExtra: true
      };
      var buff = device.getBufferManager().getBuffer(_buffRequest);
      vertexInput.addBuffer(buff, ['vertexBC']);
    } else {
      vertexInput.removeBufferIfPresent('vertexBC');
    } // normals, only used for surface rendering


    var usage = publicAPI.getUsage(representation, primType);

    if (usage === BufferUsage.Triangles || usage === BufferUsage.Strips) {
      var normals = pd.getPointData().getNormals();
      var _buffRequest2 = {
        format: 'snorm8x4',
        indexBuffer: indexBuffer,
        packExtra: true,
        shift: 0,
        scale: 127
      };

      if (normals) {
        _buffRequest2.hash = "".concat(normals.getMTime(), "I").concat(indexBuffer.getMTime(), "snorm8x4");
        _buffRequest2.dataArray = normals;
        _buffRequest2.usage = BufferUsage.PointArray;

        var _buff = device.getBufferManager().getBuffer(_buffRequest2);

        vertexInput.addBuffer(_buff, ['normalMC']);
      } else if (primType === PrimitiveTypes.Triangles) {
        _buffRequest2.hash = "PFN".concat(points.getMTime(), "I").concat(indexBuffer.getMTime(), "snorm8x4");
        _buffRequest2.dataArray = points;
        _buffRequest2.cells = cells;
        _buffRequest2.usage = BufferUsage.NormalsFromPoints;

        var _buff2 = device.getBufferManager().getBuffer(_buffRequest2);

        vertexInput.addBuffer(_buff2, ['normalMC']);
      } else {
        vertexInput.removeBufferIfPresent('normalMC');
      }
    } else {
      vertexInput.removeBufferIfPresent('normalMC');
    } // deal with colors but only if modified


    var haveColors = false;

    if (model.renderable.getScalarVisibility()) {
      var c = model.renderable.getColorMapColors();

      if (c && !edges) {
        var scalarMode = model.renderable.getScalarMode();
        var haveCellScalars = false; // We must figure out how the scalars should be mapped to the polydata.

        if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {
          haveCellScalars = true;
        }

        var _buffRequest3 = {
          usage: BufferUsage.PointArray,
          format: 'unorm8x4',
          hash: "".concat(haveCellScalars).concat(c.getMTime(), "I").concat(indexBuffer.getMTime(), "unorm8x4"),
          dataArray: c,
          indexBuffer: indexBuffer,
          cellData: haveCellScalars,
          cellOffset: 0
        };

        var _buff3 = device.getBufferManager().getBuffer(_buffRequest3);

        vertexInput.addBuffer(_buff3, ['colorVI']);
        haveColors = true;
      }
    }

    if (!haveColors) {
      vertexInput.removeBufferIfPresent('colorVI');
    }

    var tcoords = null;

    if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
    } else {
      tcoords = pd.getPointData().getTCoords();
    }

    if (tcoords && !edges) {
      var _buff4 = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());

      vertexInput.addBuffer(_buff4, ['tcoord']);
    } else {
      vertexInput.removeBufferIfPresent('tcoord');
    }
  };

  publicAPI.updateTextures = function () {
    // we keep track of new and used textures so
    // that we can clean up any unused textures so we don't hold onto them
    var usedTextures = [];
    var newTextures = []; // do we have a scalar color texture

    var idata = model.renderable.getColorTextureMap(); // returns an imagedata

    if (idata) {
      if (!model.colorTexture) {
        model.colorTexture = vtkTexture.newInstance({
          label: 'polyDataColor'
        });
      }

      model.colorTexture.setInputData(idata);
      newTextures.push(model.colorTexture);
    } // actor textures?


    var actor = model.WebGPUActor.getRenderable();
    var textures = actor.getTextures();

    for (var i = 0; i < textures.length; i++) {
      if (textures[i].getInputData() || textures[i].getJsImageData() || textures[i].getCanvas()) {
        newTextures.push(textures[i]);
      }

      if (textures[i].getImage() && textures[i].getImageLoaded()) {
        newTextures.push(textures[i]);
      }
    }

    var usedCount = 0;

    for (var _i = 0; _i < newTextures.length; _i++) {
      var srcTexture = newTextures[_i];
      var newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture);

      if (newTex.getReady()) {
        // is this a new texture
        var found = false;

        for (var t = 0; t < model.textures.length; t++) {
          if (model.textures[t] === newTex) {
            usedCount++;
            found = true;
            usedTextures[t] = true;
          }
        }

        if (!found) {
          usedTextures[model.textures.length] = true;
          var tview = newTex.createView("Texture".concat(usedCount++));
          model.textures.push(newTex);
          model.textureViews.push(tview);
          var interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';
          tview.addSampler(model.device, {
            minFilter: interpolate,
            magFilter: interpolate
          });
        }
      }
    } // remove unused textures


    for (var _i2 = model.textures.length - 1; _i2 >= 0; _i2--) {
      if (!usedTextures[_i2]) {
        model.textures.splice(_i2, 1);
        model.textureViews.splice(_i2, 1);
      }
    }
  }; // compute a unique hash for a pipeline, this needs to be unique enough to
  // capture any pipeline code changes (which includes shader changes)
  // or vertex input changes/ bind groups/ etc


  publicAPI.computePipelineHash = function () {
    var pipelineHash = 'pd';

    if (model.primitiveType === PrimitiveTypes.TriangleEdges || model.primitiveType === PrimitiveTypes.TriangleStripEdges) {
      pipelineHash += 'edge';
    } else {
      if (model.vertexInput.hasAttribute("normalMC")) {
        pipelineHash += "n";
      }

      if (model.vertexInput.hasAttribute("colorVI")) {
        pipelineHash += "c";
      }

      if (model.vertexInput.hasAttribute("tcoord")) {
        pipelineHash += "t";
      }

      if (model.textures.length) {
        pipelineHash += "tx".concat(model.textures.length);
      }
    }

    if (model.SSBO) {
      pipelineHash += "ssbo";
    }

    var uhash = publicAPI.getHashFromUsage(model.usage);
    pipelineHash += uhash;
    pipelineHash += model.renderEncoder.getPipelineHash();
    model.pipelineHash = pipelineHash;
  };

  publicAPI.updateBuffers = function () {
    // handle textures if not edges
    if (model.primitiveType !== PrimitiveTypes.TriangleEdges && model.primitiveType !== PrimitiveTypes.TriangleStripEdges) {
      publicAPI.updateTextures();
    }

    var actor = model.WebGPUActor.getRenderable();
    var rep = actor.getProperty().getRepresentation(); // handle per primitive type

    model.usage = publicAPI.getUsage(rep, model.primitiveType);
    publicAPI.buildVertexInput();
    var vbo = model.vertexInput.getBuffer('vertexBC');
    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
    publicAPI.updateUBO();

    if (publicAPI.haveWideLines()) {
      var ppty = actor.getProperty();
      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));
    }
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  cellArray: null,
  currentInput: null,
  cellOffset: 0,
  primitiveType: 0,
  colorTexture: null,
  renderEncoder: null,
  textures: null
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkWebGPUSimpleMapper.extend(publicAPI, model, initialValues);
  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
  model._tmpMat3 = mat3.identity(new Float64Array(9));
  model._tmpMat4 = mat4.identity(new Float64Array(16));
  model.UBO = vtkWebGPUUniformBuffer.newInstance({
    label: 'mapperUBO'
  });
  model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');
  model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');
  model.UBO.addEntry('AmbientColor', 'vec4<f32>');
  model.UBO.addEntry('DiffuseColor', 'vec4<f32>');
  model.UBO.addEntry('EdgeColor', 'vec4<f32>');
  model.UBO.addEntry('SpecularColor', 'vec4<f32>');
  model.UBO.addEntry('AmbientIntensity', 'f32');
  model.UBO.addEntry('DiffuseIntensity', 'f32');
  model.UBO.addEntry('SpecularIntensity', 'f32');
  model.UBO.addEntry('LineWidth', 'f32');
  model.UBO.addEntry('Opacity', 'f32');
  model.UBO.addEntry('SpecularPower', 'f32');
  model.UBO.addEntry('PropID', 'u32'); // Build VTK API

  setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'primitiveType', 'renderEncoder']);
  model.textures = []; // Object methods

  vtkWebGPUCellArrayMapper(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = newInstance$1(extend, 'vtkWebGPUCellArrayMapper'); // ----------------------------------------------------------------------------

var vtkWebGPUCellArrayMapper$1 = {
  newInstance: newInstance,
  extend: extend
};

export { vtkWebGPUCellArrayMapper$1 as default, extend, newInstance };
